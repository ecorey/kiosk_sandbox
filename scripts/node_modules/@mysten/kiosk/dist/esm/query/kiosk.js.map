{
  "version": 3,
  "sources": ["../../../src/query/kiosk.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type {\n\tPaginationArguments,\n\tSuiClient,\n\tSuiObjectData,\n\tSuiObjectDataFilter,\n\tSuiObjectResponse,\n} from '@mysten/sui.js/client';\nimport { isValidSuiAddress } from '@mysten/sui.js/utils';\n\nimport type {\n\tFetchKioskOptions,\n\tKioskExtension,\n\tKioskListing,\n\tOwnedKiosks,\n\tPagedKioskData,\n} from '../types/index.js';\nimport { KIOSK_OWNER_CAP } from '../types/index.js';\nimport {\n\tattachListingsAndPrices,\n\tattachLockedItems,\n\tattachObjects,\n\textractKioskData,\n\tgetAllDynamicFields,\n\tgetAllObjects,\n\tgetKioskObject,\n} from '../utils.js';\n\nexport async function fetchKiosk(\n\tclient: SuiClient,\n\tkioskId: string,\n\tpagination: PaginationArguments<string>,\n\toptions: FetchKioskOptions,\n): Promise<PagedKioskData> {\n\t// TODO: Replace the `getAllDynamicFields` with a paginated\n\t// response, once we have better RPC support for\n\t// type filtering & batch fetching.\n\t// This can't work with pagination currently.\n\tconst data = await getAllDynamicFields(client, kioskId, pagination);\n\n\tconst listings: KioskListing[] = [];\n\tconst lockedItemIds: string[] = [];\n\n\t// extracted kiosk data.\n\tconst kioskData = extractKioskData(data, listings, lockedItemIds, kioskId);\n\n\t// split the fetching in two queries as we are most likely passing different options for each kind.\n\t// For items, we usually seek the Display.\n\t// For listings we usually seek the DF value (price) / exclusivity.\n\tconst [kiosk, listingObjects, items] = await Promise.all([\n\t\toptions.withKioskFields ? getKioskObject(client, kioskId) : Promise.resolve(undefined),\n\t\toptions.withListingPrices\n\t\t\t? getAllObjects(client, kioskData.listingIds, {\n\t\t\t\t\tshowContent: true,\n\t\t\t  })\n\t\t\t: Promise.resolve([]),\n\t\toptions.withObjects\n\t\t\t? getAllObjects(client, kioskData.itemIds, options.objectOptions || { showDisplay: true })\n\t\t\t: Promise.resolve([]),\n\t]);\n\n\tif (options.withKioskFields) kioskData.kiosk = kiosk;\n\t// attach items listings. IF we have `options.withListingPrices === true`, it will also attach the prices.\n\tattachListingsAndPrices(kioskData, listings, listingObjects);\n\t// add `locked` status to items that are locked.\n\tattachLockedItems(kioskData, lockedItemIds);\n\n\t// Attach the objects for the queried items.\n\tattachObjects(\n\t\tkioskData,\n\t\titems.filter((x) => !!x.data).map((x) => x.data!),\n\t);\n\n\treturn {\n\t\tdata: kioskData,\n\t\tnextCursor: null,\n\t\thasNextPage: false,\n\t};\n}\n\n/**\n * A function to fetch all the user's kiosk Caps\n * And a list of the kiosk address ids.\n * Returns a list of `kioskOwnerCapIds` and `kioskIds`.\n * Extra options allow pagination.\n */\nexport async function getOwnedKiosks(\n\tclient: SuiClient,\n\taddress: string,\n\toptions?: {\n\t\tpagination?: PaginationArguments<string>;\n\t\tpersonalKioskType: string;\n\t},\n): Promise<OwnedKiosks> {\n\tif (!isValidSuiAddress(address))\n\t\treturn {\n\t\t\tnextCursor: null,\n\t\t\thasNextPage: false,\n\t\t\tkioskOwnerCaps: [],\n\t\t\tkioskIds: [],\n\t\t};\n\n\tconst filter: SuiObjectDataFilter = {\n\t\tMatchAny: [\n\t\t\t{\n\t\t\t\tStructType: KIOSK_OWNER_CAP,\n\t\t\t},\n\t\t],\n\t};\n\n\tif (options?.personalKioskType) {\n\t\tfilter.MatchAny.push({\n\t\t\tStructType: options.personalKioskType,\n\t\t});\n\t}\n\n\t// fetch owned kiosk caps, paginated.\n\tconst { data, hasNextPage, nextCursor } = await client.getOwnedObjects({\n\t\towner: address,\n\t\tfilter,\n\t\toptions: {\n\t\t\tshowContent: true,\n\t\t\tshowType: true,\n\t\t},\n\t\t...(options?.pagination || {}),\n\t});\n\n\t// get kioskIds from the OwnerCaps.\n\tconst kioskIdList = data?.map((x: SuiObjectResponse) => {\n\t\tconst fields = x.data?.content?.dataType === 'moveObject' ? x.data.content.fields : null;\n\t\t// @ts-ignore-next-line TODO: should i remove ts ignore here?\n\t\treturn (fields?.cap ? fields?.cap?.fields?.for : fields?.for) as string;\n\t\t// return (fields as { for: string })?.for;\n\t});\n\n\t// clean up data that might have an error in them.\n\t// only return valid objects.\n\tconst filteredData = data.filter((x) => 'data' in x).map((x) => x.data) as SuiObjectData[];\n\n\treturn {\n\t\tnextCursor,\n\t\thasNextPage,\n\t\tkioskOwnerCaps: filteredData.map((x, idx) => ({\n\t\t\tisPersonal: x.type !== KIOSK_OWNER_CAP,\n\t\t\tdigest: x.digest,\n\t\t\tversion: x.version,\n\t\t\tobjectId: x.objectId,\n\t\t\tkioskId: kioskIdList[idx],\n\t\t})),\n\t\tkioskIds: kioskIdList,\n\t};\n}\n\n// Get a kiosk extension data for a given kioskId and extensionType.\nexport async function fetchKioskExtension(\n\tclient: SuiClient,\n\tkioskId: string,\n\textensionType: string,\n): Promise<KioskExtension | null> {\n\tconst extension = await client.getDynamicFieldObject({\n\t\tparentId: kioskId,\n\t\tname: {\n\t\t\ttype: `0x2::kiosk_extension::ExtensionKey<${extensionType}>`,\n\t\t\tvalue: {\n\t\t\t\tdummy_field: false,\n\t\t\t},\n\t\t},\n\t});\n\n\tif (!extension.data) return null;\n\n\tconst fields = (extension?.data?.content as { fields: { [k: string]: any } })?.fields?.value\n\t\t?.fields;\n\n\treturn {\n\t\tobjectId: extension.data.objectId,\n\t\ttype: extensionType,\n\t\tisEnabled: fields?.is_enabled,\n\t\tpermissions: fields?.permissions,\n\t\tstorageId: fields?.storage?.fields?.id?.id,\n\t\tstorageSize: fields?.storage?.fields?.size,\n\t};\n}\n"],
  "mappings": "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",
  "names": []
}
