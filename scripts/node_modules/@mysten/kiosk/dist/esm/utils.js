import { normalizeStructTag, normalizeSuiAddress, parseStructTag } from "@mysten/sui.js/utils";
import { bcs } from "./bcs.js";
import { KIOSK_TYPE, TRANSFER_POLICY_CAP_TYPE } from "./types/index.js";
const DEFAULT_QUERY_LIMIT = 50;
async function getKioskObject(client, id) {
  const queryRes = await client.getObject({ id, options: { showBcs: true } });
  if (!queryRes || queryRes.error || !queryRes.data) {
    throw new Error(`Kiosk ${id} not found; ${queryRes.error}`);
  }
  if (!queryRes.data.bcs || !("bcsBytes" in queryRes.data.bcs)) {
    throw new Error(`Invalid kiosk query: ${id}, expected object, got package`);
  }
  return bcs.de(KIOSK_TYPE, queryRes.data.bcs.bcsBytes, "base64");
}
function extractKioskData(data, listings, lockedItemIds, kioskId) {
  return data.reduce(
    (acc, val) => {
      const type = val.name.type;
      if (type.startsWith("0x2::kiosk::Item")) {
        acc.itemIds.push(val.objectId);
        acc.items.push({
          objectId: val.objectId,
          type: val.objectType,
          isLocked: false,
          kioskId
        });
      }
      if (type.startsWith("0x2::kiosk::Listing")) {
        acc.listingIds.push(val.objectId);
        listings.push({
          objectId: val.name.value.id,
          listingId: val.objectId,
          isExclusive: val.name.value.is_exclusive
        });
      }
      if (type.startsWith("0x2::kiosk::Lock")) {
        lockedItemIds?.push(val.name.value.id);
      }
      if (type.startsWith("0x2::kiosk_extension::ExtensionKey")) {
        acc.extensions.push({
          objectId: val.objectId,
          type: normalizeStructTag(parseStructTag(val.name.type).typeParams[0])
        });
      }
      return acc;
    },
    { items: [], itemIds: [], listingIds: [], extensions: [] }
  );
}
function attachListingsAndPrices(kioskData, listings, listingObjects) {
  const itemListings = listings.reduce(
    (acc, item, idx) => {
      acc[item.objectId] = { ...item };
      if (listingObjects.length === 0)
        return acc;
      const content = listingObjects[idx].data?.content;
      const data = content?.dataType === "moveObject" ? content?.fields : null;
      if (!data)
        return acc;
      acc[item.objectId].price = data.value;
      return acc;
    },
    {}
  );
  kioskData.items.forEach((item) => {
    item.listing = itemListings[item.objectId] || void 0;
  });
}
function attachObjects(kioskData, objects) {
  const mapping = objects.reduce(
    (acc, obj) => {
      acc[obj.objectId] = obj;
      return acc;
    },
    {}
  );
  kioskData.items.forEach((item) => {
    item.data = mapping[item.objectId] || void 0;
  });
}
function attachLockedItems(kioskData, lockedItemIds) {
  const lockedStatuses = lockedItemIds.reduce(
    (acc, item) => {
      acc[item] = true;
      return acc;
    },
    {}
  );
  kioskData.items.forEach((item) => {
    item.isLocked = lockedStatuses[item.objectId] || false;
  });
}
async function getAllDynamicFields(client, parentId, pagination) {
  let hasNextPage = true;
  let cursor = void 0;
  const data = [];
  while (hasNextPage) {
    const result = await client.getDynamicFields({
      parentId,
      limit: pagination.limit || void 0,
      cursor
    });
    data.push(...result.data);
    hasNextPage = result.hasNextPage;
    cursor = result.nextCursor;
  }
  return data;
}
async function getAllObjects(client, ids, options, limit = DEFAULT_QUERY_LIMIT) {
  const chunks = Array.from(
    { length: Math.ceil(ids.length / limit) },
    (_, index) => ids.slice(index * limit, index * limit + limit)
  );
  const results = await Promise.all(
    chunks.map((chunk) => {
      return client.multiGetObjects({
        ids: chunk,
        options
      });
    })
  );
  return results.flat();
}
async function getAllOwnedObjects({
  client,
  owner,
  filter,
  limit = DEFAULT_QUERY_LIMIT,
  options = { showType: true, showContent: true }
}) {
  let hasNextPage = true;
  let cursor = void 0;
  const data = [];
  while (hasNextPage) {
    const result = await client.getOwnedObjects({
      owner,
      filter,
      limit,
      cursor,
      options
    });
    data.push(...result.data);
    hasNextPage = result.hasNextPage;
    cursor = result.nextCursor;
  }
  return data;
}
function percentageToBasisPoints(percentage) {
  if (percentage < 0 || percentage > 100)
    throw new Error("Percentage needs to be in the [0,100] range.");
  return Math.ceil(percentage * 100);
}
function parseTransferPolicyCapObject(item) {
  const type = item?.data?.content?.type;
  const policy = item?.data?.content?.fields?.policy_id;
  if (!type.includes(TRANSFER_POLICY_CAP_TYPE))
    return void 0;
  const objectType = type.replace(TRANSFER_POLICY_CAP_TYPE + "<", "").slice(0, -1);
  return {
    policyId: policy,
    policyCapId: item.data?.objectId,
    type: objectType
  };
}
function getNormalizedRuleType(rule) {
  const normalizedRuleAddress = rule.split("::");
  normalizedRuleAddress[0] = normalizeSuiAddress(normalizedRuleAddress[0]);
  return normalizedRuleAddress.join("::");
}
export {
  attachListingsAndPrices,
  attachLockedItems,
  attachObjects,
  extractKioskData,
  getAllDynamicFields,
  getAllObjects,
  getAllOwnedObjects,
  getKioskObject,
  getNormalizedRuleType,
  parseTransferPolicyCapObject,
  percentageToBasisPoints
};
//# sourceMappingURL=utils.js.map
