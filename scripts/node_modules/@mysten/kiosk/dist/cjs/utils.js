"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var utils_exports = {};
__export(utils_exports, {
  attachListingsAndPrices: () => attachListingsAndPrices,
  attachLockedItems: () => attachLockedItems,
  attachObjects: () => attachObjects,
  extractKioskData: () => extractKioskData,
  getAllDynamicFields: () => getAllDynamicFields,
  getAllObjects: () => getAllObjects,
  getAllOwnedObjects: () => getAllOwnedObjects,
  getKioskObject: () => getKioskObject,
  getNormalizedRuleType: () => getNormalizedRuleType,
  parseTransferPolicyCapObject: () => parseTransferPolicyCapObject,
  percentageToBasisPoints: () => percentageToBasisPoints
});
module.exports = __toCommonJS(utils_exports);
var import_utils = require("@mysten/sui.js/utils");
var import_bcs = require("./bcs.js");
var import_types = require("./types/index.js");
const DEFAULT_QUERY_LIMIT = 50;
async function getKioskObject(client, id) {
  const queryRes = await client.getObject({ id, options: { showBcs: true } });
  if (!queryRes || queryRes.error || !queryRes.data) {
    throw new Error(`Kiosk ${id} not found; ${queryRes.error}`);
  }
  if (!queryRes.data.bcs || !("bcsBytes" in queryRes.data.bcs)) {
    throw new Error(`Invalid kiosk query: ${id}, expected object, got package`);
  }
  return import_bcs.bcs.de(import_types.KIOSK_TYPE, queryRes.data.bcs.bcsBytes, "base64");
}
function extractKioskData(data, listings, lockedItemIds, kioskId) {
  return data.reduce(
    (acc, val) => {
      const type = val.name.type;
      if (type.startsWith("0x2::kiosk::Item")) {
        acc.itemIds.push(val.objectId);
        acc.items.push({
          objectId: val.objectId,
          type: val.objectType,
          isLocked: false,
          kioskId
        });
      }
      if (type.startsWith("0x2::kiosk::Listing")) {
        acc.listingIds.push(val.objectId);
        listings.push({
          objectId: val.name.value.id,
          listingId: val.objectId,
          isExclusive: val.name.value.is_exclusive
        });
      }
      if (type.startsWith("0x2::kiosk::Lock")) {
        lockedItemIds?.push(val.name.value.id);
      }
      if (type.startsWith("0x2::kiosk_extension::ExtensionKey")) {
        acc.extensions.push({
          objectId: val.objectId,
          type: (0, import_utils.normalizeStructTag)((0, import_utils.parseStructTag)(val.name.type).typeParams[0])
        });
      }
      return acc;
    },
    { items: [], itemIds: [], listingIds: [], extensions: [] }
  );
}
function attachListingsAndPrices(kioskData, listings, listingObjects) {
  const itemListings = listings.reduce(
    (acc, item, idx) => {
      acc[item.objectId] = { ...item };
      if (listingObjects.length === 0)
        return acc;
      const content = listingObjects[idx].data?.content;
      const data = content?.dataType === "moveObject" ? content?.fields : null;
      if (!data)
        return acc;
      acc[item.objectId].price = data.value;
      return acc;
    },
    {}
  );
  kioskData.items.forEach((item) => {
    item.listing = itemListings[item.objectId] || void 0;
  });
}
function attachObjects(kioskData, objects) {
  const mapping = objects.reduce(
    (acc, obj) => {
      acc[obj.objectId] = obj;
      return acc;
    },
    {}
  );
  kioskData.items.forEach((item) => {
    item.data = mapping[item.objectId] || void 0;
  });
}
function attachLockedItems(kioskData, lockedItemIds) {
  const lockedStatuses = lockedItemIds.reduce(
    (acc, item) => {
      acc[item] = true;
      return acc;
    },
    {}
  );
  kioskData.items.forEach((item) => {
    item.isLocked = lockedStatuses[item.objectId] || false;
  });
}
async function getAllDynamicFields(client, parentId, pagination) {
  let hasNextPage = true;
  let cursor = void 0;
  const data = [];
  while (hasNextPage) {
    const result = await client.getDynamicFields({
      parentId,
      limit: pagination.limit || void 0,
      cursor
    });
    data.push(...result.data);
    hasNextPage = result.hasNextPage;
    cursor = result.nextCursor;
  }
  return data;
}
async function getAllObjects(client, ids, options, limit = DEFAULT_QUERY_LIMIT) {
  const chunks = Array.from(
    { length: Math.ceil(ids.length / limit) },
    (_, index) => ids.slice(index * limit, index * limit + limit)
  );
  const results = await Promise.all(
    chunks.map((chunk) => {
      return client.multiGetObjects({
        ids: chunk,
        options
      });
    })
  );
  return results.flat();
}
async function getAllOwnedObjects({
  client,
  owner,
  filter,
  limit = DEFAULT_QUERY_LIMIT,
  options = { showType: true, showContent: true }
}) {
  let hasNextPage = true;
  let cursor = void 0;
  const data = [];
  while (hasNextPage) {
    const result = await client.getOwnedObjects({
      owner,
      filter,
      limit,
      cursor,
      options
    });
    data.push(...result.data);
    hasNextPage = result.hasNextPage;
    cursor = result.nextCursor;
  }
  return data;
}
function percentageToBasisPoints(percentage) {
  if (percentage < 0 || percentage > 100)
    throw new Error("Percentage needs to be in the [0,100] range.");
  return Math.ceil(percentage * 100);
}
function parseTransferPolicyCapObject(item) {
  const type = item?.data?.content?.type;
  const policy = item?.data?.content?.fields?.policy_id;
  if (!type.includes(import_types.TRANSFER_POLICY_CAP_TYPE))
    return void 0;
  const objectType = type.replace(import_types.TRANSFER_POLICY_CAP_TYPE + "<", "").slice(0, -1);
  return {
    policyId: policy,
    policyCapId: item.data?.objectId,
    type: objectType
  };
}
function getNormalizedRuleType(rule) {
  const normalizedRuleAddress = rule.split("::");
  normalizedRuleAddress[0] = (0, import_utils.normalizeSuiAddress)(normalizedRuleAddress[0]);
  return normalizedRuleAddress.join("::");
}
//# sourceMappingURL=utils.js.map
