"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var kiosk_transaction_exports = {};
__export(kiosk_transaction_exports, {
  KioskTransaction: () => KioskTransaction
});
module.exports = __toCommonJS(kiosk_transaction_exports);
var kioskTx = __toESM(require("../tx/kiosk.js"));
var import_personal_kiosk = require("../tx/personal-kiosk.js");
var import_transfer_policy = require("../tx/transfer-policy.js");
var import_utils = require("../utils.js");
var _pendingShare, _pendingTransfer, _promise, _personalCap, _finalized, _borrowFromPersonalCap, borrowFromPersonalCap_fn, _setPendingStatuses, setPendingStatuses_fn, _validateKioskIsSet, validateKioskIsSet_fn, _validateFinalizedStatus, validateFinalizedStatus_fn;
class KioskTransaction {
  constructor({ transactionBlock, kioskClient, cap }) {
    /**
     * A function to borrow from `personalCap`.
     */
    __privateAdd(this, _borrowFromPersonalCap);
    __privateAdd(this, _setPendingStatuses);
    __privateAdd(this, _validateKioskIsSet);
    // Validates that `finalize`
    __privateAdd(this, _validateFinalizedStatus);
    // If we're pending `share` of a new kiosk, `finalize()` will share it.
    __privateAdd(this, _pendingShare, void 0);
    // If we're pending transferring of the cap, `finalize()` will either error or transfer the cap if it's a new personal.
    __privateAdd(this, _pendingTransfer, void 0);
    // The promise that the personalCap will be returned on `finalize()`.
    __privateAdd(this, _promise, void 0);
    // The personal kiosk argument.
    __privateAdd(this, _personalCap, void 0);
    // A flag that checks whether kiosk TX is finalized.
    __privateAdd(this, _finalized, false);
    this.transactionBlock = transactionBlock;
    this.kioskClient = kioskClient;
    if (cap)
      this.setCap(cap);
  }
  /**
   * Creates a kiosk and saves `kiosk` and `kioskOwnerCap` in state.
   * Helpful if we want to chain some actions before sharing + transferring the cap to the specified address.
   * @param borrow If true, the `kioskOwnerCap` is borrowed from the `PersonalKioskCap` to be used in next transactions.
   */
  create() {
    __privateMethod(this, _validateFinalizedStatus, validateFinalizedStatus_fn).call(this);
    __privateMethod(this, _setPendingStatuses, setPendingStatuses_fn).call(this, {
      share: true,
      transfer: true
    });
    const [kiosk, cap] = kioskTx.createKiosk(this.transactionBlock);
    this.kiosk = kiosk;
    this.kioskCap = cap;
    return this;
  }
  /**
   * Creates a personal kiosk & shares it.
   * The `PersonalKioskCap` is transferred to the signer.
   * @param borrow If true, the `kioskOwnerCap` is borrowed from the `PersonalKioskCap` to be used in next transactions.
   */
  createPersonal(borrow) {
    __privateSet(this, _pendingShare, true);
    return this.create().convertToPersonal(borrow);
  }
  /**
   * Converts a kiosk to a Personal (Soulbound) Kiosk.
   * Requires initialization by either calling `ktxb.create()` or `ktxb.setCap()`.
   */
  convertToPersonal(borrow) {
    __privateMethod(this, _validateKioskIsSet, validateKioskIsSet_fn).call(this);
    const cap = (0, import_personal_kiosk.convertToPersonalTx)(
      this.transactionBlock,
      this.kiosk,
      this.kioskCap,
      this.kioskClient.getRulePackageId("personalKioskRulePackageId")
    );
    if (borrow)
      __privateMethod(this, _borrowFromPersonalCap, borrowFromPersonalCap_fn).call(this, cap);
    else
      __privateSet(this, _personalCap, cap);
    __privateMethod(this, _setPendingStatuses, setPendingStatuses_fn).call(this, { transfer: true });
    return this;
  }
  /**
   * Single function way to create a kiosk, share it and transfer the cap to the specified address.
   */
  createAndShare(address) {
    __privateMethod(this, _validateFinalizedStatus, validateFinalizedStatus_fn).call(this);
    const cap = kioskTx.createKioskAndShare(this.transactionBlock);
    this.transactionBlock.transferObjects([cap], this.transactionBlock.pure.address(address));
  }
  /**
   * Shares the kiosk.
   */
  share() {
    __privateMethod(this, _validateKioskIsSet, validateKioskIsSet_fn).call(this);
    __privateMethod(this, _setPendingStatuses, setPendingStatuses_fn).call(this, { share: false });
    kioskTx.shareKiosk(this.transactionBlock, this.kiosk);
  }
  /**
   * Should be called only after `create` is called.
   * It shares the kiosk & transfers the cap to the specified address.
   */
  shareAndTransferCap(address) {
    if (__privateGet(this, _personalCap))
      throw new Error("You can only call `shareAndTransferCap` on a non-personal kiosk.");
    __privateMethod(this, _setPendingStatuses, setPendingStatuses_fn).call(this, { transfer: false });
    this.share();
    this.transactionBlock.transferObjects(
      [this.kioskCap],
      this.transactionBlock.pure.address(address)
    );
  }
  /**
   * A function to borrow an item from a kiosk & execute any function with it.
   * Example: You could borrow a Fren out of a kiosk, attach an accessory (or mix), and return it.
   */
  borrowTx({ itemType, itemId }, callback) {
    __privateMethod(this, _validateKioskIsSet, validateKioskIsSet_fn).call(this);
    const [itemObj, promise] = kioskTx.borrowValue(
      this.transactionBlock,
      itemType,
      this.kiosk,
      this.kioskCap,
      itemId
    );
    callback(itemObj);
    this.return({ itemType, item: itemObj, promise });
  }
  /**
   * Borrows an item from the kiosk.
   * This will fail if the item is listed for sale.
   *
   * Requires calling `return`.
   */
  borrow({ itemType, itemId }) {
    __privateMethod(this, _validateKioskIsSet, validateKioskIsSet_fn).call(this);
    const [itemObj, promise] = kioskTx.borrowValue(
      this.transactionBlock,
      itemType,
      this.kiosk,
      this.kioskCap,
      itemId
    );
    return [itemObj, promise];
  }
  /**
   * Returns the item back to the kiosk.
   * Accepts the parameters returned from the `borrow` function.
   */
  return({ itemType, item, promise }) {
    __privateMethod(this, _validateKioskIsSet, validateKioskIsSet_fn).call(this);
    kioskTx.returnValue(this.transactionBlock, itemType, this.kiosk, item, promise);
    return this;
  }
  /**
   * A function to withdraw from kiosk
   * @param address Where to trasnfer the coin.
   * @param amount The amount we aim to withdraw.
   */
  withdraw(address, amount) {
    __privateMethod(this, _validateKioskIsSet, validateKioskIsSet_fn).call(this);
    const coin = kioskTx.withdrawFromKiosk(
      this.transactionBlock,
      this.kiosk,
      this.kioskCap,
      amount
    );
    this.transactionBlock.transferObjects([coin], this.transactionBlock.pure.address(address));
    return this;
  }
  /**
   * A function to place an item in the kiosk.
   * @param itemType The type `T` of the item
   * @param item The ID or Transaction Argument of the item
   */
  place({ itemType, item }) {
    __privateMethod(this, _validateKioskIsSet, validateKioskIsSet_fn).call(this);
    kioskTx.place(this.transactionBlock, itemType, this.kiosk, this.kioskCap, item);
    return this;
  }
  /**
   * A function to place an item in the kiosk and list it for sale in one transaction.
   * @param itemType The type `T` of the item
   * @param item The ID or Transaction Argument of the item
   * @param price The price in MIST
   */
  placeAndList({ itemType, item, price }) {
    __privateMethod(this, _validateKioskIsSet, validateKioskIsSet_fn).call(this);
    kioskTx.placeAndList(this.transactionBlock, itemType, this.kiosk, this.kioskCap, item, price);
    return this;
  }
  /**
   * A function to list an item in the kiosk.
   * @param itemType The type `T` of the item
   * @param itemId The ID of the item
   * @param price The price in MIST
   */
  list({ itemType, itemId, price }) {
    __privateMethod(this, _validateKioskIsSet, validateKioskIsSet_fn).call(this);
    kioskTx.list(this.transactionBlock, itemType, this.kiosk, this.kioskCap, itemId, price);
    return this;
  }
  /**
   * A function to delist an item from the kiosk.
   * @param itemType The type `T` of the item
   * @param itemId The ID of the item
   */
  delist({ itemType, itemId }) {
    __privateMethod(this, _validateKioskIsSet, validateKioskIsSet_fn).call(this);
    kioskTx.delist(this.transactionBlock, itemType, this.kiosk, this.kioskCap, itemId);
    return this;
  }
  /**
  	 * A function to take an item from the kiosk. The transaction won't succeed if the item is listed or locked.
  
  	 * @param itemType The type `T` of the item
  	 * @param itemId The ID of the item
  	 */
  take({ itemType, itemId }) {
    __privateMethod(this, _validateKioskIsSet, validateKioskIsSet_fn).call(this);
    return kioskTx.take(this.transactionBlock, itemType, this.kiosk, this.kioskCap, itemId);
  }
  /**
   * Transfer a non-locked/non-listed item to an address.
   *
   * @param itemType The type `T` of the item
   * @param itemId The ID of the item
   * @param address The destination address
   */
  transfer({ itemType, itemId, address }) {
    __privateMethod(this, _validateKioskIsSet, validateKioskIsSet_fn).call(this);
    const item = this.take({ itemType, itemId });
    this.transactionBlock.transferObjects([item], this.transactionBlock.pure.address(address));
    return this;
  }
  /**
  	 * A function to take lock an item in the kiosk.
  
  	 * @param itemType The type `T` of the item
  	 * @param item The ID or Transaction Argument of the item
  	 * @param itemId The ID of the item - Deprecated: Use `item` instead.
  	 * @param policy The Policy ID or Transaction Argument for item T
  	 */
  lock({
    itemType,
    item,
    itemId,
    policy
  }) {
    __privateMethod(this, _validateKioskIsSet, validateKioskIsSet_fn).call(this);
    kioskTx.lock(
      this.transactionBlock,
      itemType,
      this.kiosk,
      this.kioskCap,
      policy,
      itemId ?? item
    );
    return this;
  }
  /**
   * Purchase an item from a seller's kiosk.
   * Returns [item, transferRequest]
   * Can be called like: `const [item, transferRequest] = kioskTx.purchase({...})`
   * @param itemType The type `T` of the item
   * @param itemId The ID of the item
   * @param price The price in MIST
   * @param sellerKiosk The kiosk which is selling the item. Can be an id or an object argument.
   */
  purchase({
    itemType,
    itemId,
    price,
    sellerKiosk
  }) {
    const coin = this.transactionBlock.splitCoins(this.transactionBlock.gas, [
      this.transactionBlock.pure.u64(price)
    ]);
    return kioskTx.purchase(this.transactionBlock, itemType, sellerKiosk, itemId, coin);
  }
  /**
   * A function to purchase and resolve a transfer policy.
   * If the transfer policy has the `lock` rule, the item is locked in the kiosk.
   * Otherwise, the item is placed in the kiosk.
   * @param itemType The type of the item
   * @param itemId The id of the item
   * @param price The price of the specified item
   * @param sellerKiosk The kiosk which is selling the item. Can be an id or an object argument.
   * @param extraArgs Used to pass arguments for custom rule resolvers.
   */
  async purchaseAndResolve({
    itemType,
    itemId,
    price,
    sellerKiosk,
    extraArgs
  }) {
    __privateMethod(this, _validateKioskIsSet, validateKioskIsSet_fn).call(this);
    const policies = await this.kioskClient.getTransferPolicies({ type: itemType });
    if (policies.length === 0) {
      throw new Error(
        `The type ${itemType} doesn't have a Transfer Policy so it can't be traded through kiosk.`
      );
    }
    const policy = policies[0];
    const [purchasedItem, transferRequest] = this.purchase({
      itemType,
      itemId,
      price,
      sellerKiosk
    });
    let canTransferOutsideKiosk = true;
    for (const rule of policy.rules) {
      const ruleDefinition = this.kioskClient.rules.find(
        (x) => (0, import_utils.getNormalizedRuleType)(x.rule) === (0, import_utils.getNormalizedRuleType)(rule)
      );
      if (!ruleDefinition)
        throw new Error(`No resolver for the following rule: ${rule}.`);
      if (ruleDefinition.hasLockingRule)
        canTransferOutsideKiosk = false;
      ruleDefinition.resolveRuleFunction({
        packageId: ruleDefinition.packageId,
        transactionBlock: this.transactionBlock,
        itemType,
        itemId,
        price: price.toString(),
        sellerKiosk,
        policyId: policy.id,
        transferRequest,
        purchasedItem,
        kiosk: this.kiosk,
        kioskCap: this.kioskCap,
        extraArgs: extraArgs || {}
      });
    }
    (0, import_transfer_policy.confirmRequest)(this.transactionBlock, itemType, policy.id, transferRequest);
    if (canTransferOutsideKiosk)
      this.place({ itemType, item: purchasedItem });
    return this;
  }
  /**
   * A function to setup the client using an existing `ownerCap`,
   * as return from the `kioskClient.getOwnedKiosks` function.
   * @param cap `KioskOwnerCap` object as returned from `getOwnedKiosks` SDK call.
   */
  setCap(cap) {
    __privateMethod(this, _validateFinalizedStatus, validateFinalizedStatus_fn).call(this);
    this.kiosk = this.transactionBlock.object(cap.kioskId);
    if (!cap.isPersonal) {
      this.kioskCap = this.transactionBlock.object(cap.objectId);
      return;
    }
    return __privateMethod(this, _borrowFromPersonalCap, borrowFromPersonalCap_fn).call(this, cap.objectId);
  }
  /**
   *	A function that ends up the kiosk building txb & returns the `kioskOwnerCap` back to the
   *  `PersonalKioskCap`, in case we are operating on a personal kiosk.
   * 	It will also share the `kiosk` if it's not shared, and finalize the transfer of the personal cap if it's pending.
   */
  finalize() {
    __privateMethod(this, _validateKioskIsSet, validateKioskIsSet_fn).call(this);
    if (__privateGet(this, _pendingShare))
      this.share();
    if (!__privateGet(this, _personalCap)) {
      if (__privateGet(this, _pendingTransfer))
        throw new Error(
          "You need to transfer the `kioskOwnerCap` by calling `shareAndTransferCap()` before wrap"
        );
      return;
    }
    const packageId = this.kioskClient.getRulePackageId("personalKioskRulePackageId");
    if (__privateGet(this, _promise)) {
      this.transactionBlock.moveCall({
        target: `${packageId}::personal_kiosk::return_val`,
        arguments: [
          __privateGet(this, _personalCap),
          this.transactionBlock.object(this.kioskCap),
          __privateGet(this, _promise)
        ]
      });
    }
    if (__privateGet(this, _pendingTransfer))
      (0, import_personal_kiosk.transferPersonalCapTx)(this.transactionBlock, __privateGet(this, _personalCap), packageId);
    __privateSet(this, _finalized, true);
  }
  // Some setters in case we want custom behavior.
  setKioskCap(cap) {
    __privateMethod(this, _validateFinalizedStatus, validateFinalizedStatus_fn).call(this);
    this.kioskCap = cap;
    return this;
  }
  setKiosk(kiosk) {
    __privateMethod(this, _validateFinalizedStatus, validateFinalizedStatus_fn).call(this);
    this.kiosk = kiosk;
    return this;
  }
  // Some getters
  /*
   * Returns the active transaction's kiosk, or undefined if `setCap` or `create()` hasn't been called yet.
   */
  getKiosk() {
    __privateMethod(this, _validateFinalizedStatus, validateFinalizedStatus_fn).call(this);
    if (!this.kiosk)
      throw new Error("Kiosk is not set.");
    return this.kiosk;
  }
  /*
   * Returns the active transaction's kioskOwnerCap, or undefined if `setCap` or `create()` hasn't been called yet.
   */
  getKioskCap() {
    __privateMethod(this, _validateFinalizedStatus, validateFinalizedStatus_fn).call(this);
    if (!this.kioskCap)
      throw new Error("Kiosk cap is not set");
    return this.kioskCap;
  }
}
_pendingShare = new WeakMap();
_pendingTransfer = new WeakMap();
_promise = new WeakMap();
_personalCap = new WeakMap();
_finalized = new WeakMap();
_borrowFromPersonalCap = new WeakSet();
borrowFromPersonalCap_fn = function(personalCap) {
  const [kioskCap, promise] = this.transactionBlock.moveCall({
    target: `${this.kioskClient.getRulePackageId(
      "personalKioskRulePackageId"
    )}::personal_kiosk::borrow_val`,
    arguments: [this.transactionBlock.object(personalCap)]
  });
  this.kioskCap = kioskCap;
  __privateSet(this, _personalCap, this.transactionBlock.object(personalCap));
  __privateSet(this, _promise, promise);
  return this;
};
_setPendingStatuses = new WeakSet();
setPendingStatuses_fn = function({ share, transfer }) {
  if (transfer !== void 0)
    __privateSet(this, _pendingTransfer, transfer);
  if (share !== void 0)
    __privateSet(this, _pendingShare, share);
};
_validateKioskIsSet = new WeakSet();
validateKioskIsSet_fn = function() {
  __privateMethod(this, _validateFinalizedStatus, validateFinalizedStatus_fn).call(this);
  if (!this.kiosk || !this.kioskCap)
    throw new Error(
      "You need to initialize the client by either supplying an existing owner cap or by creating a new by calling `.create()`"
    );
};
_validateFinalizedStatus = new WeakSet();
validateFinalizedStatus_fn = function() {
  if (__privateGet(this, _finalized))
    throw new Error("You can't add more transactions to a finalized kiosk transaction block.");
};
//# sourceMappingURL=kiosk-transaction.js.map
