"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var kiosk_client_exports = {};
__export(kiosk_client_exports, {
  KioskClient: () => KioskClient
});
module.exports = __toCommonJS(kiosk_client_exports);
var import_constants = require("../constants.js");
var import_kiosk = require("../query/kiosk.js");
var import_transfer_policy = require("../query/transfer-policy.js");
var import_types = require("../types/index.js");
class KioskClient {
  constructor(options) {
    this.client = options.client;
    this.network = options.network;
    this.rules = import_constants.rules;
    this.packageIds = options.packageIds;
    if (options.packageIds)
      this.rules.push(...(0, import_constants.getBaseRules)(options.packageIds));
  }
  /// Querying
  /**
   * Get an addresses's owned kiosks.
   * @param address The address for which we want to retrieve the kiosks.
   * @returns An Object containing all the `kioskOwnerCap` objects as well as the kioskIds.
   */
  async getOwnedKiosks({ address }) {
    const personalPackageId = this.packageIds?.personalKioskRulePackageId || import_constants.PERSONAL_KIOSK_RULE_ADDRESS[this.network];
    return (0, import_kiosk.getOwnedKiosks)(this.client, address, {
      personalKioskType: personalPackageId ? `${personalPackageId}::personal_kiosk::PersonalKioskCap` : ""
    });
  }
  /**
   * Fetches the kiosk contents.
   * @param kioskId The ID of the kiosk to fetch.
   * @param options Optioal
   * @returns
   */
  async getKiosk({ id, options }) {
    return (await (0, import_kiosk.fetchKiosk)(
      this.client,
      id,
      {
        limit: 1e3
      },
      options || {}
    )).data;
  }
  /**
   * Fetch the extension data (if any) for a kiosk, by type
   * @param kioskId The ID of the kiosk to lookup
   * @param extensionType The Type of the extension (can be used from by using the type returned by `getKiosk()`)
   */
  async getKioskExtension({ kioskId, type }) {
    return (0, import_kiosk.fetchKioskExtension)(this.client, kioskId, type);
  }
  /**
   * Query the Transfer Policy(ies) for type `T`.
   * @param type The Type we're querying for (E.g `0xMyAddress::hero::Hero`)
   */
  async getTransferPolicies({ type }) {
    return (0, import_transfer_policy.queryTransferPolicy)(this.client, type);
  }
  /**
   * Query all the owned transfer policies for an address.
   * Returns `TransferPolicyCap` which uncludes `policyId, policyCapId, type`.
   * @param address The address we're searching the owned transfer policies for.
   */
  async getOwnedTransferPolicies({ address }) {
    return (0, import_transfer_policy.queryOwnedTransferPolicies)(this.client, address);
  }
  /**
   * Query the Transfer Policy Cap for type `T`, owned by `address`
   * @param type The Type `T` for the object
   * @param address The address that owns the cap.
   */
  async getOwnedTransferPoliciesByType({ type, address }) {
    return (0, import_transfer_policy.queryTransferPolicyCapsByType)(this.client, address, type);
  }
  // Someone would just have to create a `kiosk-client.ts` file in their project, initialize a KioskClient
  // and call the `addRuleResolver` function. Each rule has a `resolve` function.
  // The resolve function is automatically called on `purchaseAndResolve` function call.
  addRuleResolver(rule) {
    if (this.rules.find((x) => x.rule === rule.rule))
      throw new Error(`Rule ${rule.rule} resolver already exists.`);
    this.rules.push(rule);
  }
  /**
   * A convenient helper to get the packageIds for our supported ruleset,
   * based on `kioskClient` configuration.
   */
  getRulePackageId(rule) {
    const rules2 = this.packageIds || {};
    const network = this.network;
    if (!rules2[rule] && network !== import_types.Network.MAINNET && network !== import_types.Network.TESTNET) {
      throw new Error(`Missing packageId for rule ${rule}`);
    }
    switch (rule) {
      case "kioskLockRulePackageId":
        return rules2[rule] || import_constants.KIOSK_LOCK_RULE_ADDRESS[network];
      case "royaltyRulePackageId":
        return rules2[rule] || import_constants.ROYALTY_RULE_ADDRESS[network];
      case "personalKioskRulePackageId":
        return rules2[rule] || import_constants.PERSONAL_KIOSK_RULE_ADDRESS[network];
      case "floorPriceRulePackageId":
        return rules2[rule] || import_constants.FLOOR_PRICE_RULE_ADDRESS[network];
    }
  }
}
//# sourceMappingURL=kiosk-client.js.map
