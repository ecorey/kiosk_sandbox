"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var tp_transaction_exports = {};
__export(tp_transaction_exports, {
  TransferPolicyTransaction: () => TransferPolicyTransaction
});
module.exports = __toCommonJS(tp_transaction_exports);
var import_attach = require("../tx/rules/attach.js");
var import_transfer_policy = require("../tx/transfer-policy.js");
var _validateInputs, validateInputs_fn, _setup, setup_fn;
class TransferPolicyTransaction {
  constructor({ kioskClient, transactionBlock, cap }) {
    // Internal function that that the policy's Id + Cap + type have been set.
    __privateAdd(this, _validateInputs);
    /**
     * Setup the state of the TransferPolicyTransaction.
     */
    __privateAdd(this, _setup);
    this.kioskClient = kioskClient;
    this.transactionBlock = transactionBlock;
    if (cap)
      this.setCap(cap);
  }
  /**
   * A function to create a new transfer policy.
   * Checks if there's already an existing transfer policy to prevent
   * double transfer polciy mistakes.
   * There's an optional `skipCheck` flag that will just create the policy
   * without checking
   *
   * @param type The Type (`T`) for which we're creating the transfer policy.
   * @param publisher The Publisher Object Id.
   * @param address Address to save the `TransferPolicyCap` object to.
   * @param skipCheck (Optional) skip checking if a transfer policy already exists
   */
  async createAndShare({
    type,
    publisher,
    address,
    skipCheck
  }) {
    if (!skipCheck) {
      const policies = await this.kioskClient.getTransferPolicies({ type });
      if (policies.length > 0)
        throw new Error("There's already transfer policy for this Type.");
    }
    const cap = (0, import_transfer_policy.createTransferPolicy)(this.transactionBlock, type, publisher);
    this.transactionBlock.transferObjects([cap], this.transactionBlock.pure.address(address));
  }
  /**
   * A convenient function to create a Transfer Policy and attach some rules
   * before sharing it (so you can prepare it in a single PTB)
   * @param type The Type (`T`) for which we're creating the transfer policy.
   * @param publisher The Publisher Object Id.
   * @param address Address to save the `TransferPolicyCap` object to.
   * @param skipCheck (Optional) skip checking if a transfer policy already exists
   */
  async create({
    type,
    publisher,
    skipCheck
  }) {
    if (!skipCheck) {
      const policies = await this.kioskClient.getTransferPolicies({ type });
      if (policies.length > 0)
        throw new Error("There's already transfer policy for this Type.");
    }
    const [policy, policyCap] = (0, import_transfer_policy.createTransferPolicyWithoutSharing)(
      this.transactionBlock,
      type,
      publisher
    );
    __privateMethod(this, _setup, setup_fn).call(this, policy, policyCap, type);
    return this;
  }
  /**
   * This can be called after calling the `create` function to share the `TransferPolicy`,
   * and transfer the `TransferPolicyCap` to the specified address
   *
   * @param address The address to transfer the `TransferPolicyCap`
   */
  shareAndTransferCap(address) {
    if (!this.type || !this.policyCap || !this.policy)
      throw new Error("This function can only be called after `transferPolicyManager.create`");
    (0, import_transfer_policy.shareTransferPolicy)(this.transactionBlock, this.type, this.policy);
    this.transactionBlock.transferObjects(
      [this.policyCap],
      this.transactionBlock.pure.address(address)
    );
  }
  /**
   * Setup the TransferPolicy by passing a `cap` returned from `kioskClient.getOwnedTransferPolicies` or
   * `kioskClient.getOwnedTransferPoliciesByType`.
   * @param policyCapId The `TransferPolicyCap`
   */
  setCap({ policyId, policyCapId, type }) {
    return __privateMethod(this, _setup, setup_fn).call(this, policyId, policyCapId, type);
  }
  /**
   * Withdraw from the transfer policy's profits.
   * @param address Address to transfer the profits to.
   * @param amount (Optional) amount parameter. Will withdraw all profits if the amount is not specified.
   */
  withdraw(address, amount) {
    __privateMethod(this, _validateInputs, validateInputs_fn).call(this);
    const coin = (0, import_transfer_policy.withdrawFromPolicy)(
      this.transactionBlock,
      this.type,
      this.policy,
      this.policyCap,
      amount
    );
    this.transactionBlock.transferObjects([coin], this.transactionBlock.pure.address(address));
    return this;
  }
  /**
   *  Adds the Kiosk Royalty rule to the Transfer Policy.
   *  You can pass the percentage, as well as a minimum amount.
   *  The royalty that will be paid is the MAX(percentage, minAmount).
   * 	You can pass 0 in either value if you want only percentage royalty, or a fixed amount fee.
   * 	(but you should define at least one of them for the rule to make sense).
   *
   * 	@param percentageBps The royalty percentage in basis points. Use `percentageToBasisPoints` helper to convert from percentage [0,100].
   * 	@param minAmount The minimum royalty amount per request in MIST.
   */
  addRoyaltyRule(percentageBps, minAmount) {
    __privateMethod(this, _validateInputs, validateInputs_fn).call(this);
    (0, import_attach.attachRoyaltyRuleTx)(
      this.transactionBlock,
      this.type,
      this.policy,
      this.policyCap,
      percentageBps,
      minAmount,
      this.kioskClient.getRulePackageId("royaltyRulePackageId")
    );
    return this;
  }
  /**
   * Adds the Kiosk Lock Rule to the Transfer Policy.
   * This Rule forces buyer to lock the item in the kiosk, preserving strong royalties.
   */
  addLockRule() {
    __privateMethod(this, _validateInputs, validateInputs_fn).call(this);
    (0, import_attach.attachKioskLockRuleTx)(
      this.transactionBlock,
      this.type,
      this.policy,
      this.policyCap,
      this.kioskClient.getRulePackageId("kioskLockRulePackageId")
    );
    return this;
  }
  /**
   * Attaches the Personal Kiosk Rule, making a purchase valid only for `SoulBound` kiosks.
   */
  addPersonalKioskRule() {
    __privateMethod(this, _validateInputs, validateInputs_fn).call(this);
    (0, import_attach.attachPersonalKioskRuleTx)(
      this.transactionBlock,
      this.type,
      this.policy,
      this.policyCap,
      this.kioskClient.getRulePackageId("personalKioskRulePackageId")
    );
    return this;
  }
  /**
   * A function to add the floor price rule to a transfer policy.
   * @param minPrice The minimum price in MIST.
   */
  addFloorPriceRule(minPrice) {
    __privateMethod(this, _validateInputs, validateInputs_fn).call(this);
    (0, import_attach.attachFloorPriceRuleTx)(
      this.transactionBlock,
      this.type,
      this.policy,
      this.policyCap,
      minPrice,
      this.kioskClient.getRulePackageId("floorPriceRulePackageId")
    );
    return this;
  }
  /**
   * Generic helper to remove a rule, not from the SDK's base ruleset.
   * @param ruleType The Rule Type
   * @param configType The Config Type
   */
  removeRule({ ruleType, configType }) {
    __privateMethod(this, _validateInputs, validateInputs_fn).call(this);
    (0, import_transfer_policy.removeTransferPolicyRule)(
      this.transactionBlock,
      this.type,
      ruleType,
      configType,
      this.policy,
      this.policyCap
    );
  }
  /**
   * Removes the lock rule.
   */
  removeLockRule() {
    __privateMethod(this, _validateInputs, validateInputs_fn).call(this);
    const packageId = this.kioskClient.getRulePackageId("kioskLockRulePackageId");
    (0, import_transfer_policy.removeTransferPolicyRule)(
      this.transactionBlock,
      this.type,
      `${packageId}::kiosk_lock_rule::Rule`,
      `${packageId}::kiosk_lock_rule::Config`,
      this.policy,
      this.policyCap
    );
    return this;
  }
  /**
   * Removes the Royalty rule
   */
  removeRoyaltyRule() {
    __privateMethod(this, _validateInputs, validateInputs_fn).call(this);
    const packageId = this.kioskClient.getRulePackageId("royaltyRulePackageId");
    (0, import_transfer_policy.removeTransferPolicyRule)(
      this.transactionBlock,
      this.type,
      `${packageId}::royalty_rule::Rule`,
      `${packageId}::royalty_rule::Config`,
      this.policy,
      this.policyCap
    );
    return this;
  }
  removePersonalKioskRule() {
    __privateMethod(this, _validateInputs, validateInputs_fn).call(this);
    const packageId = this.kioskClient.getRulePackageId("personalKioskRulePackageId");
    (0, import_transfer_policy.removeTransferPolicyRule)(
      this.transactionBlock,
      this.type,
      `${packageId}::personal_kiosk_rule::Rule`,
      `bool`,
      this.policy,
      this.policyCap
    );
    return this;
  }
  removeFloorPriceRule() {
    __privateMethod(this, _validateInputs, validateInputs_fn).call(this);
    const packageId = this.kioskClient.getRulePackageId("floorPriceRulePackageId");
    (0, import_transfer_policy.removeTransferPolicyRule)(
      this.transactionBlock,
      this.type,
      `${packageId}::floor_price_rule::Rule`,
      `${packageId}::floor_price_rule::Config`,
      this.policy,
      this.policyCap
    );
    return this;
  }
  getPolicy() {
    if (!this.policy)
      throw new Error("Policy not set.");
    return this.policy;
  }
  getPolicyCap() {
    if (!this.policyCap)
      throw new Error("Transfer Policy Cap not set.");
    return this.policyCap;
  }
}
_validateInputs = new WeakSet();
validateInputs_fn = function() {
  const genericErrorMessage = `Please use 'setCap()' to setup the TransferPolicy.`;
  if (!this.policy)
    throw new Error(`${genericErrorMessage} Missing: Transfer Policy Object.`);
  if (!this.policyCap)
    throw new Error(`${genericErrorMessage} Missing: TransferPolicyCap Object ID`);
  if (!this.type)
    throw new Error(
      `${genericErrorMessage} Missing: Transfer Policy object type (e.g. {packageId}::item::Item)`
    );
};
_setup = new WeakSet();
setup_fn = function(policyId, policyCap, type) {
  this.policy = policyId;
  this.policyCap = policyCap;
  this.type = type;
  return this;
};
//# sourceMappingURL=tp-transaction.js.map
