"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var kiosk_exports = {};
__export(kiosk_exports, {
  borrowValue: () => borrowValue,
  createKiosk: () => createKiosk,
  createKioskAndShare: () => createKioskAndShare,
  delist: () => delist,
  list: () => list,
  lock: () => lock,
  place: () => place,
  placeAndList: () => placeAndList,
  purchase: () => purchase,
  returnValue: () => returnValue,
  shareKiosk: () => shareKiosk,
  take: () => take,
  withdrawFromKiosk: () => withdrawFromKiosk
});
module.exports = __toCommonJS(kiosk_exports);
var import_bcs = require("@mysten/sui.js/bcs");
var import_types = require("../types/index.js");
function createKiosk(tx) {
  const [kiosk, kioskOwnerCap] = tx.moveCall({
    target: `${import_types.KIOSK_MODULE}::new`
  });
  return [kiosk, kioskOwnerCap];
}
function createKioskAndShare(tx) {
  const [kiosk, kioskOwnerCap] = createKiosk(tx);
  shareKiosk(tx, kiosk);
  return kioskOwnerCap;
}
function shareKiosk(tx, kiosk) {
  tx.moveCall({
    target: `0x2::transfer::public_share_object`,
    typeArguments: [import_types.KIOSK_TYPE],
    arguments: [kiosk]
  });
}
function place(tx, itemType, kiosk, kioskCap, item) {
  tx.moveCall({
    target: `${import_types.KIOSK_MODULE}::place`,
    typeArguments: [itemType],
    arguments: [tx.object(kiosk), tx.object(kioskCap), tx.object(item)]
  });
}
function lock(tx, itemType, kiosk, kioskCap, policy, item) {
  tx.moveCall({
    target: `${import_types.KIOSK_MODULE}::lock`,
    typeArguments: [itemType],
    arguments: [tx.object(kiosk), tx.object(kioskCap), tx.object(policy), tx.object(item)]
  });
}
function take(tx, itemType, kiosk, kioskCap, itemId) {
  const [item] = tx.moveCall({
    target: `${import_types.KIOSK_MODULE}::take`,
    typeArguments: [itemType],
    arguments: [tx.object(kiosk), tx.object(kioskCap), tx.pure.id(itemId)]
  });
  return item;
}
function list(tx, itemType, kiosk, kioskCap, itemId, price) {
  tx.moveCall({
    target: `${import_types.KIOSK_MODULE}::list`,
    typeArguments: [itemType],
    arguments: [tx.object(kiosk), tx.object(kioskCap), tx.pure.id(itemId), tx.pure.u64(price)]
  });
}
function delist(tx, itemType, kiosk, kioskCap, itemId) {
  tx.moveCall({
    target: `${import_types.KIOSK_MODULE}::delist`,
    typeArguments: [itemType],
    arguments: [tx.object(kiosk), tx.object(kioskCap), tx.pure.id(itemId)]
  });
}
function placeAndList(tx, itemType, kiosk, kioskCap, item, price) {
  tx.moveCall({
    target: `${import_types.KIOSK_MODULE}::place_and_list`,
    typeArguments: [itemType],
    arguments: [tx.object(kiosk), tx.object(kioskCap), tx.object(item), tx.pure.u64(price)]
  });
}
function purchase(tx, itemType, kiosk, itemId, payment) {
  const [item, transferRequest] = tx.moveCall({
    target: `${import_types.KIOSK_MODULE}::purchase`,
    typeArguments: [itemType],
    arguments: [tx.object(kiosk), tx.pure.id(itemId), tx.object(payment)]
  });
  return [item, transferRequest];
}
function withdrawFromKiosk(tx, kiosk, kioskCap, amount) {
  const amountArg = import_bcs.bcs.option(import_bcs.bcs.u64()).serialize(amount);
  const [coin] = tx.moveCall({
    target: `${import_types.KIOSK_MODULE}::withdraw`,
    arguments: [tx.object(kiosk), tx.object(kioskCap), amountArg]
  });
  return coin;
}
function borrowValue(tx, itemType, kiosk, kioskCap, itemId) {
  const [item, promise] = tx.moveCall({
    target: `${import_types.KIOSK_MODULE}::borrow_val`,
    typeArguments: [itemType],
    arguments: [tx.object(kiosk), tx.object(kioskCap), tx.pure.id(itemId)]
  });
  return [item, promise];
}
function returnValue(tx, itemType, kiosk, item, promise) {
  tx.moveCall({
    target: `${import_types.KIOSK_MODULE}::return_val`,
    typeArguments: [itemType],
    arguments: [tx.object(kiosk), item, promise]
  });
}
//# sourceMappingURL=kiosk.js.map
